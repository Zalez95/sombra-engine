#ifndef HACD_H
#define HACD_H

#include <memory>
#include "AABB.h"
#include "HalfEdgeMesh.h"
#include "HalfEdgeMeshRaycast.h"

namespace se::physics {

	template <typename T> struct GraphVertex;
	template <typename T> struct Graph;


	/**
	 * Class HACD, it's used to calculate the aproximate convex decomposition
	 * of any given HalfEdgeMesh
	 */
	class HACD
	{
	private:	// Nested types
		using DualGraphVertex = GraphVertex< std::vector<int> >;
		using DualGraph = Graph< std::vector<int> >;
		using FaceNormals = utils::PackedVector<glm::vec3>;
		using HEMeshWithNormals = std::pair<HalfEdgeMesh, FaceNormals>;

		/** Struct QHACDData, it holds the data that the HACD algorithm will
		 * need at each iteration for deciding which Edge of the DualGraph
		 * should be collapsed */
		struct QHACDData
		{
			/** The indices of the Graph Vertices of the Edge */
			int iVertex1, iVertex2;

			/** The cost of merging this Graph Edge */
			float cost;

			/** The concavity of the mesh created from the vertices and their
			 * ancestors */
			float concavity;

			/** Tells if the QHACDData should be removed or not */
			bool remove;

			/** Compares the given QHACDData
			 *
			 * @param	d1 the first QHACDData to compare
			 * @param	d2 the second QHACDData to compare
			 * @return	true if the first QHACDData has a higher cost than
			 *			the second one, false otherwise */
			friend bool operator>(const QHACDData& d1, const QHACDData& d2)
			{ return d1.cost > d2.cost; };
		};

	private:	// Attributes
		/** The maximum kd-tree height for the generated raycasts */
		constexpr static unsigned int kMaxKDTreeHeight = 8;

		/** The maximum concavity of the dual graph edges needed for HACD
		 * algorithm. It's value is a proportion of the HalfEdgeMesh size */
		const float mMaximumConcavity;

		/** The epsilon value needed for the comparisons during the HACD
		 * algorithm computation */
		const float mEpsilon;

		/** The mesh to apply the HACD algorithm. Its faces must be triangles */
		HalfEdgeMesh mMesh;

		/** The normal vectors of the HEFaces of the Mesh to apply the HACD
		 * algorithm */
		FaceNormals mFaceNormals;

		/** The object used for calculating ray hits with the current HEMesh */
		HalfEdgeMeshRaycast<kMaxKDTreeHeight> mMeshRaycast;

		/** The Dual Graph asociated with mesh to decompose. Each vertex in
		 * this graph is a triangle in the mesh, and each vertex in the Graph
		 * is connected to another one if the triangle that corresponds to that
		 * vertex shares an edge with another triangle. The data of each vertex
		 * is a vector of ancestor vertices ordered ascendently */
		std::unique_ptr<DualGraph> mDualGraph;

		/** The length of HalfEdgeMesh AABB diagonal */
		float mAABBSize;

		/** The precision of the comparison scaled with the size of the
		 * HalfEdgeMesh to calculate */
		float mScaledEpsilon;

		/** The factors used for calculating the decimation cost */
		float mAlpha, mBeta, mGamma;

		/** The convex HalfEdgeMeshes and its normal vectors in which the
		 * concave mesh has been decomposed */
		std::vector<HEMeshWithNormals> mConvexMeshes;

	public:		// Functions
		/** Creates a new HACD object
		 *
		 * @param	maximumConcavity the maximum concavity needed for HACD
		 *			algorithm
		 * @param	epsilon the epsilon value for the comparisons during
		 *			the HACD algorithm computation */
		HACD(float maximumConcavity, float epsilon);

		/** Class destructor */
		~HACD();

		/** @return	the HalfEdgeMeshes and their Normals vectors generated by
		 *			the HACD algorithm */
		const std::vector<HEMeshWithNormals>& getMeshes() const
		{ return mConvexMeshes; };

		/** Decomposes the given mesh into multiple convex ones with the HACD
		 * algorithm
		 *
		 * @param	originalMesh the Half-Edge data structure with the 3D Mesh
		 *			to decompose with the HACD algorithm */
		void calculate(const HalfEdgeMesh& originalMesh);

		/** Resets the HACD data for the next calculations */
		void resetData();
	private:
		/** Initializes all the data needed for the HACD algorithm computation
		 *
		 * @param	originalMesh the Half-Edge data structure with the 3D Mesh
		 *			to decompose with the HACD algorithm */
		void initData(const HalfEdgeMesh& originalMesh);

		/** Creates and return a new QHACDData created from the given vertices
		 * and the HACD data
		 *
		 * @param	vertex1 the first of the Graph vertices
		 * @param	vertex2 the second of the Graph vertices
		 * @return	the new QHACDData */
		QHACDData createQHACDData(
			const DualGraphVertex& vertex1, const DualGraphVertex& vertex2
		) const;

		/** Adds the vertex 2 and its ancestors to the first one
		 *
		 * @param	vertex1 the first vertex. It's the vertex whose ancestors
		 *			will be updated
		 * @param	vertex2 the second vertex */
		static void updateAncestors(
			DualGraphVertex& vertex1, const DualGraphVertex& vertex2
		);

		/** Compares the given QHACDDatas
		 *
		 * @param	qd1 the first QHACDData to compare
		 * @param	qd2 the second QHACDData to compare
		 * @return	true if both QHACDData holds the same vertex id */
		static bool compareVertexIds(
			const QHACDData& qd1, const QHACDData& qd2
		);

		/** Computes the convex surfaces from the partitions of the current
		 * dual graph and the triangulated mesh */
		void computeConvexSurfaces();

		/** Creates the initial Dual Graph with the triangles of the Mesh.
 		 *
		 * @param	meshData the Half-Edge Mesh from which we want to create
		 *			the dual graph
		 * @return	the dual graph of the mesh */
		static DualGraph createDualGraph(const HalfEdgeMesh& meshData);

		/** Calculates the contribution of the Aspect Ratio to the cost function
		 *
		 * @param	maximumConcavity the maximum concavity of the dual graph
		 *			edges
		 * @param	normalizationFactor the normalization factor
		 * @return	the aspect ratio factor */
		static float calculateAspectRatioFactor(
			float maximumConcavity, float normalizationFactor
		);

		/** Calculates the HEFace indices of the surface created from the given
		 * Graph vertices and their ancestors
		 *
		 * @param	iVertex1 the first Graph vertex
		 * @param	iVertex2 the second Graph vertex
		 * @return	the HEFace indices of the surface */
		static std::vector<int> calculateSurfaceFaceIndices(
			const DualGraphVertex& vertex1, const DualGraphVertex& vertex2
		);

		/** Creates a new HEMesh from the provided HEFaces of the given HEMesh
		 *
		 * @param	iFaces the indices of the HEFaces of the meshData
		 *			we want to create the new HEMesh
		 * @param	meshData the HalfEdgeMesh that holds the HEFaces
		 * @param	faceNormals the normal vectors of each HEFace in the
		 *			meshData
		 * @return	a pair with new HEMesh and its face normals */
		static HEMeshWithNormals getMeshFromIndices(
			const std::vector<int>& iFaces,
			const HalfEdgeMesh& meshData, const FaceNormals& faceNormals
		);

		/** Calculates the concavity of the original HalfEdgeMesh as the square
		 * root of the difference between the areas of the convex hull and the
		 * original HalfEdgeMesh
		 *
		 * @param	originalArea the area of the HalfEdgeMesh to calculate
		 *			its concavity
		 * @param	convexHullArea the area of the convex hull of the
		 *			originalMesh
		 * @return	the concavity of the surface in 2D */
		static float calculateConcavity2D(
			float originalArea, float convexHullArea
		);

		/** Calculates the maximum concavity of the given 3D HalfEdgeMesh as the
		 * maximum distance from a point on its surface to its convex hull.
		 *
		 * @param	originalMesh the HalfEdgeMesh to calculate its concavity
		 * @param	originalMeshNormals the normal vectors of the originalMesh
		 *			HEFaces
		 * @param	convexHullMesh the convex hull HalfEdgeMesh of the
		 *			originalMesh
		 * @param	convexHullNormals the normal vectors of the convexHullMesh
		 *			HEFaces
		 * @return	the concavity of the surface
		 * @note	the points to be used for the Concavity calculation are the
		 *			vertices and the centroid of each HEFace */
		float calculateConcavity3D(
			const HalfEdgeMesh& originalMesh,
			const FaceNormals& originalMeshNormals,
			const HalfEdgeMesh& convexHullMesh,
			const FaceNormals& convexHullNormals
		) const;

		/** Calculate the aspect ratio of the given HEMesh
		 *
		 * @param	meshData the HalfEdgeMesh to calculate its aspect ratio
		 * @return	the aspect ratio of the HEMesh */
		static float calculateAspectRatio(const HalfEdgeMesh& meshData);
	};

}

#endif		// HACD_H
